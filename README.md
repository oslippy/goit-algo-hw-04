# Порівняльний аналіз алгоритмів сортування

Цей проект порівнює три різні алгоритми сортування, щоб зрозуміти, який з них працює найшвидше на різних типах даних. Протестовано сортування злиттям (Merge Sort), сортування вставками (Insertion Sort) та вбудований алгоритм Python - Timsort.

## Що саме тестувалось?

Я використав модуль `timeit` для точного вимірювання часу виконання кожного алгоритму. Тестування проводилося на різних наборах даних:
- Випадкові числа
- Вже відсортовані дані
- Дані, відсортовані у зворотному порядку
- Частково відсортовані дані

Розміри масивів були від 100 до 10000 елементів, щоб побачити, як алгоритми поводяться на малих і великих обсягах даних.

## Що виявилося?

### На випадкових даних

Timsort переміг на всіх розмірах масивів. Наприклад, для масиву з 10000 елементів:
- Merge Sort: ~16 мс
- Insertion Sort: ~1800 мс (це дуже повільно!)
- Timsort: ~0.8 мс

Insertion Sort показує квадратичну складність - коли розмір масиву збільшується в 100 разів, час виконання зростає приблизно в 10000 разів. Це означає, що для великих масивів він стає непрактичним.

Merge Sort працює стабільно - час зростає приблизно як n*log(n), що набагато краще, ніж квадратична залежність.

Timsort показує результати, близькі до Merge Sort, але завжди трохи швидший.

### На вже відсортованих даних

Тут цікава ситуація! Insertion Sort на відсортованих даних працює дуже швидко - майже лінійно. Але Timsort все одно виграє, тому що він розуміє, що дані вже відсортовані, і просто перевіряє це, не виконуючи зайвих операцій.

Merge Sort на жаль не використовує цю перевагу - він все одно виконує повне сортування, навіть якщо дані вже відсортовані.

### На зворотно відсортованих даних

Це найгірший випадок для Insertion Sort. На масиві з 10000 елементів він працює понад 3 секунди! Merge Sort залишається стабільним, а Timsort знову виграє завдяки своїм оптимізаціям.

### На частково відсортованих даних

Timsort особливо добре працює тут, тому що він використовує insertion sort для малих підмасивів, які вже частково відсортовані. Це робить його ідеальним для реальних даних, які часто мають якусь структуру.

## Висновки

Після всіх тестів стало зрозуміло:

- **Insertion Sort** хороший для навчання і дуже малих масивів, але для реальних завдань він занадто повільний.

- **Merge Sort** надійний і передбачуваний - завжди працює добре, незалежно від даних. Але він не використовує можливості оптимізації для структурованих даних.

- **Timsort** - переможець у всіх категоріях. Він швидший, розумніший і адаптивніший.

## Як запустити?

Просто запустіть скрипт:

```bash
source .venv/bin/activate  # якщо використовуєте віртуальне середовище
python compare_sorting_algorithms.py
```

Програма покаже результати тестування для всіх типів даних та розмірів масивів, а також аналіз складності алгоритмів.
